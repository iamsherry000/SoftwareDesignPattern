# 大老二撲克牌遊戲規則 (Big-2)

## 專案難度
★★☆☆☆

## 專案簡介

這是一個大老二撲克牌遊戲的開發專案。

### 為什麼這個專案重要？

大老二撲克牌遊戲的邏輯複雜度超越了大多數企業專案的領域模型：
- **遊戲流程**：多回合、多玩家的狀態管理
- **牌型判斷**：複雜的規則驗證與比較邏輯
- **行為變動性**：4~5 道行為變動性 Forces

如果你能寫好大老二，企業中的商業邏輯對你來說幾乎是易如反掌。

---

## 詞彙表 (Glossary)

建立團隊一致認同的語言 (Ubiquitous Language)：

| 詞彙 | 英文 | 說明 |
|------|------|------|
| 大老二 | Big-2 | 我們要開發的撲克牌遊戲 |
| 玩家 | Player | 遊戲的參與者，可能為 AI 或人類玩家 (Human Player) |
| 撲克牌 | Card | (數字、花色) 的組合 |
| 數字 | Rank | 撲克牌上的數字：`{3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A, 2}` |
| 花色 | Suit | 撲克牌上的花色：`{梅花(♣), 菱形(♦), 愛心(♥), 黑桃(♠)}` |
| 牌堆 | Deck | 一副 52 張不同撲克牌的牌堆 |
| 發牌 | Deal | 玩家從牌堆中的頂部取走一張牌 |
| 手牌 | Hand cards | 玩家擁有的手牌，最少 0 張，最多 13 張 |
| 牌型 | Card Pattern | 撲克牌的組合 |
| 打牌 | Play | 玩家從手牌中打出合法牌型至檯面上的動作 |
| 回合 | Round | 遊戲會有多個回合，在每回合中，四位玩家輪流打牌，直到有三位玩家連續喊出 PASS |
| 頂牌 | Top play | 檯面上目前最大的牌型 |
| 頂牌玩家 | Top player | 打出頂牌的玩家 |

---

## 遊戲流程 (Game Flow)

### 1. 遊戲初始化
- 遊戲中有**四位玩家**
- 遊戲開始後輸入每個玩家的名稱 (Name)
- 使用數字 `{0, 1, 2, 3}` 來索引這四位玩家
- 玩家輪流規則：假設目前輪到玩家 `i`，則「下一輪的玩家」為索引值 `(i + 1) % 4` 的玩家

### 2. 發牌
- 將牌堆洗牌
- 將 52 張牌輪流發給四位玩家，直到牌堆空 (Empty) 為止
- 每位玩家最終會有 13 張手牌

### 3. 第一回合

#### 3.1 首位出牌者
- 由擁有**梅花 3**的玩家首先出牌
- 此玩家必須打出一副**合法且包含梅花 3**的牌型
- 打出來的牌型便成為目前的**頂牌**

#### 3.2 玩家輪流出牌
下一輪的玩家可以決定執行以下其一動作：
1. **喊 PASS** —— 放棄出牌機會，不打任何牌
2. **打出一副比頂牌還大的合法牌型** —— 此新打出來的牌型便成為新的頂牌

#### 3.3 回合結束條件
- 下一輪的玩家重複上述步驟
- 直到玩家們連續喊出了**三個 PASS**

### 4. 之後的回合

第一回合結束後，開始下一回合。之後的每一回合都和第一回合有著相同的步驟和規則，但多了以下規則：

#### 4.1 回合開始
- 每一回合結束之後，**檯面上的牌會被清空**（清空頂牌）
- 上一回合的**頂牌玩家**將會成為新回合的頂牌玩家
- 新的回合由頂牌玩家開始打牌，並且**不能喊 PASS**
- 舉例：如果上一回合結束時的頂牌玩家為玩家 `i`，則在新的一回合時，由玩家 `i` 開始打牌

#### 4.2 遊戲繼續
不斷地進入下一回合、下一輪，直到遊戲結束

### 5. 遊戲結束
- 當有任一玩家將所有的手牌打完時，遊戲立刻結束
- 宣告此玩家為遊戲的**贏家 (Winner)**

---

## 牌型以及牌型的大小 (Card Patterns and Ordering)

### 基本原則
- 初版需求中一共有**四種牌型**
- **只有相同種類的牌型之間可以比較大小**

### 1. 單張 (Single)

**定義：** 一張牌

**大小比較規則：** 先比數字再比花色

- **數字大小**（由小到大）：
  ```
  3 < 4 < 5 < 6 < 7 < 8 < 9 < 10 < J < Q < K < A < 2
  ```

- **花色大小**（由小到大）：
  ```
  梅花(♣) < 菱形(♦) < 愛心(♥) < 黑桃(♠)
  ```

**範例：**
- `黑桃2` > `愛心2`（同數字比花色）
- `梅花2` > `黑桃A`（2 是最大的數字）

### 2. 對子 (Pair)

**定義：** 兩張數字相同的牌

**範例：** `J-J`、`3-3`

**大小比較規則：** 將兩張牌中較大的牌作為比較基準

**範例：**
- `A-A` > `7-7`

### 3. 順子 (Straight)

**定義：** 任何連續數字的五張牌

**範例：**
- `3-4-5-6-7`
- `10-J-Q-K-A`
- `J-Q-K-A-2`
- `K-A-2-3-4`（順子可以循環）

**大小比較規則：** 將五張牌中最大的牌作為比較基準

**範例：**
- `2-3-4-5-6` > `10-J-Q-K-A`（因為 2 > A）

### 4. 葫蘆 (Full House)

**定義：** 五張牌，由兩部分構成：
- 三張數字相同的牌（三條）
- 兩張數字相同的牌（一對）

**範例：**
- `3-3-3-2-2`
- `A-A-A-7-7`

**大小比較規則：** 以三張數字相同的牌中，數字最大的牌作為比較基準

**範例：**
- `A-A-A-3-3` > `5-5-5-2-2`（比較三條部分：A > 5）

---

## 軟體設計需求：開閉原則 (Open-Closed Principle, OCP)

### 核心要求

你的大老二程式設計，必須在**「不同牌型的支援」**上遵守 OCP：

> **「在擴充新的牌型（或是刪除既有牌型）時，無須修改既有大老二設計中的所有類別程式，便能擴充。」**

### 為什麼這個要求很重要？

實務上，很少需求會明確告訴你「有哪些地方」要「遵守 OCP」。因為 OCP 是技術性用語，不在需求方的認知之中。

工程師通常只喜歡在自己的「舒適圈內」遵守 OCP。一旦面臨較複雜的擴充需求時：
- 心態容易浮躁
- 將複雜的擴充性需求坐視不管
- 導致程式碼疊床架屋，越演越烈

### 設計模式應用

本專案已經學習了以下設計模式：
1. **策略模式 (Strategy Pattern)**
2. **樣板方法 (Template Method)**
3. **責任鍊模式 (Chain of Responsibility Pattern)**

你必須：
1. 察覺需求中形成的 **Forces**
2. 定義清楚的 **Context**
3. 在適合的地方套用設計模式
4. 理性地判斷哪些部分需要 OCP

### 設計目標

- ✅ 新增牌型不需修改既有類別
- ✅ 刪除牌型不需修改既有類別
- ✅ 牌型判斷邏輯可獨立擴充
- ✅ 牌型比較邏輯可獨立擴充

---

## 測試需求

魔王題附有嚴謹的輸入/輸出測資：
- 這是真槍實彈的演練
- 必須在「嚴格的需求驗收」下完成程式碼
- 才能感受到更具體的 Forces

---

## 專案目標

1. **正確實現遊戲規則**：確保每一個遊戲規則都被準確實現
2. **設計具備擴充性**：可以在未來輕鬆地支援新的需求
3. **遵守 OCP**：在牌型支援上遵守開閉原則
4. **通過所有測資**：確保遊戲邏輯的正確性

---

## 開發建議

1. **先理解規則**：完整閱讀並理解所有遊戲規則
2. **識別 Forces**：找出程式中的變動點（4~5 道行為變動性 Forces）
3. **設計類別圖**：在寫程式前先設計好類別結構
4. **套用設計模式**：在適當的地方套用學過的設計模式
5. **測試驅動開發**：使用測資驗證你的實作

---

## 總結

通關魔王題的當下，正是你變強的過程！

- 相信學院
- 相信我
- 相信自己

你應該花多一點時間在這裡，回歸學生時期的自己，專心練等，讓自己變得更強吧！

